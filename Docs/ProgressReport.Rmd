---
title: "Progress Report"
author: "Ying Jin"
date: "2023-09-15"
output: 
  html_document:
    self_contained: no
    number_sections: true
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: true
    font: 12pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

set.seed(516)

library(here)
library(tidyverse)
library(ggpubr)
library(refund)
library(lme4)
library(ROCR)
library(GLMMadaptive)
library(kableExtra)
library(mvtnorm)
library(mgcv)
library(splines)
theme_set(theme_minimal())

# df <- read_rds(here("Data/nhanes_bi.rds"))
# load(here("Data/ApplOutput_fGFPCA.RData"))

# code
source(here("Code/GLMM-FPCA.R")) 
# use pred_latent function to estimate latent function 
source(here("Code/OutSampMLE.R"))
# source(here("Code/OutsampBayes.R"))

```

# Simulation

I am now on the way to add the debias step to the whole algorithm. Just so that I have a set of "true parameters" to comparision, I am gonna use the simulation dataset for this part.

## Generation mechanism

- I am gonna generate only one dataset as an example
- 500 individuals each with 1000 measures

\[\begin{aligned}
Y_i(t) & \sim Bernoulli(\frac{exp(\eta_i(t))}{1+exp(\eta_i(t))}) \\
\eta_i(t) &= f_0(t)+ \xi_{i1}\sqrt{2}sin(2\pi t)+\xi_{i2}\sqrt{2}cos(2\pi t)+\xi_{i3}\sqrt{2}sin(4\pi t)+\xi_{i4}\sqrt{2}cos(4\pi t)
\end{aligned}\]

where:

- $t$ is equal-spaced on $[0, 1]$
- $f_0(t)=0$
- $\xi_k \sim N(0, \lambda_k)$, and $\lambda_k = 1, 0.5, 0.25, 0.125$ for k = 1, 2, 3, 4 respectively. 


```{r gen_data, class.source='show'}
N <- 500 # sample size
J <- 1000 # number of observation points

t = seq(0,1,len=J) # observations points

# mean function
f_0 <- function(s) 0 

#eigenfunctions 
K <- 4 # number of eigenfunctions
phi <- sqrt(2)*cbind(sin(2*pi*t),cos(2*pi*t),
                     sin(4*pi*t),cos(4*pi*t))

# eigenvalues
lambda = 0.5^(0:(K-1)) 

# generated data 
## score
xi <- matrix(rnorm(N*K),N,K)
xi <- xi %*% diag(sqrt(lambda))
  
# subject-specific random effect
b_i <- xi %*% t(phi); # of size N by J
  
# latent gaussian function
eta_i <- t(vapply(1:N, function(x){
    f_0(t) + b_i[x,]
  }, numeric(J)))
  
# outcome binary function
Y_i <- matrix(rbinom(N*J, size=1, prob=plogis(eta_i)), 
                N, J, byrow=FALSE)
  
# format into dataframe
# id = subject identifier (factor variable)
# sind = numeric value corresponding to the observed functional domain
# Y = functional response (binary)
# sind_inx = numeric value associated with order of "sind"
#            this is not necessary, but may be of convenience when you implement the method
df <- data.frame(id = factor(rep(1:N, each=J)),
                 t = rep(t, N), 
                 Y = as.vector(t(Y_i)),
                 eta_i = as.vector(t(eta_i)),
                 sind = rep(1:J, N))
# visualization
rand_id <- sample(N, size = 4)
df %>% filter(id %in% rand_id) %>% 
  ggplot()+
  geom_point(aes(x=sind, y=Y))+
  geom_line(aes(x=sind, y=plogis(eta_i)), col = "red")+
  #geom_line(aes(x=sind_inx, y=eta_i), col = "blue")+
  facet_wrap(~id)
```

## fGFPCA model fitting

### Bin ata

- Bin every 10 consecutive observations

```{r, message=FALSE}
# bin data
bin_w <- 10 # bin width
n_bin <- J/bin_w # number of bins
brks <- seq(0, J, by = bin_w) # cutoff points
mid <- (brks+bin_w/2)[1:n_bin] # mid points

df$bin <- cut(df$sind, breaks = brks, include.lowest = T, labels = mid)
df$bin <- as.numeric(as.character(df$bin))
# unique(df$bin)

df %>% 
  filter(id %in% rand_id) %>%
  group_by(id, bin) %>%
  summarise(num = sum(Y)) %>%
  ggplot()+
  geom_point(aes(x=bin, y=num), size = 0.5)+
  facet_wrap(~id)+
  labs(x="Time", y = "Activity", title = "Number of active nimutes within each bin")
```

## Data split

- 400 subjects for training, 100 for out-of-sample prediction

```{r}
train_id <- sample(unique(df$id), size = N*0.8)
test_id <- setdiff(unique(df$id), train_id)

train_df <- df %>% filter(id %in% train_id)
test_df <- df %>% filter(id %in% test_id)
```

### Local GLMM

- Used glmer with PIRLS (nAGQ=0) for local GLMMs step
- Fit on the training set

```{r, cache=TRUE}
# fit model on the training set
train_bin_lst <- split(train_df, f = train_df$bin)

# local GLMM and estimate latent function
# use PIRLS (nAGQ=0) to avoid near-unidentifiability issues 
t1=Sys.time()
df_est_latent <- lapply(train_bin_lst, function(x){pred_latent(x, n_node = 0)}) 
t2= Sys.time()
t_local_glmm <- t2-t1 
```


```{r}
df_est_latent <- bind_rows(df_est_latent) 
# head(df_est_latent)

# example estimated latent function
df_est_latent %>% 
  filter(id %in% rand_id) %>%
  mutate(eta_hat = exp(eta_hat)/(1+exp(eta_hat))) %>%
  mutate(eta_i = exp(eta_i)/(1+exp(eta_i))) %>%
  ggplot()+
  geom_line(aes(x=sind, y=eta_hat, group = id, col = "estimated"))+
  geom_line(aes(x=sind, y=eta_i, group = id, col = "true"))+
  geom_point(aes(x=sind, y = Y, group = id), size = 0.5)+
  facet_wrap(~id, scales = "free")+
  labs(x = "Time", y = "Estimated latent function (probablity scale)")
```

### FPCA

```{r}
uni_eta_hat <- df_est_latent %>% filter(bin==sind)

mat_est_unique <- matrix(uni_eta_hat$eta_hat,
                         nrow=length(train_id), 
                         ncol=n_bin, byrow = F) 
# row index subject, column binned time
# dim(mat_est_unique)

t1 <- Sys.time()
fpca_mod <- fpca.face(mat_est_unique, argvals = mid, var=T)
t2 <- Sys.time()
t_fpca <- t2-t1 # 3.21 seconds to fit fPCA model
```

```{r}
plot(mid, fpca_mod$mu, type = "l", xlab = "bin", ylab = "mean")
```


```{r, fig.height=8, fig.width=8}
par(mfrow=c(2,2))

plot(mid, fpca_mod$efunctions[, 1], type="l", xlab="bin", ylab="PC1")
plot(mid, fpca_mod$efunctions[, 2], type="l", xlab="bin", ylab="PC2")
plot(mid, fpca_mod$efunctions[, 3], type="l", xlab="bin", ylab="PC3")
plot(mid, fpca_mod$efunctions[, 4], type="l", xlab="bin", ylab="PC4")
```

```{r}
# plot correlation matrix
heatmap(cov2cor(fpca_mod$VarMats[[1]]), Rowv = NA, Colv = NA, main = "Correlation")
```

### Debias (step 4)

According to the fGFPCA paper, in this step we do two things: 

1. Project the eigenfunctions with B-spline basis back to the original grid
2. Debias the eigenvalues with GLMM (mgcv::bam, mgcm::gamm or gamm4:gamm) to be used for Laplace approximation

- The bias was caused by the misspecification of latent process (assume constant effect over smooth function). 
- What needs re-evaluation are eigenvalues (variance estimates). They will be used in Laplace Approximation for out-of-sample prediction. 
- We do not need to debias individual scores because the scores for training sample will not be used for out-of-sample prediction

#### Debias with GLMM model

First I'd like to try to fit the debias GLMM model on the full training set with un-interpolated eigenfunctions. I am using mgcv::bam and setting method = "fREML" and discrete = TRUE to speed up computation

```{r}
df_phi <- data.frame(bin=mid, fpca_mod$efunctions[, 1:4])
colnames(df_phi) <- c("bin", paste0("phi", 1:4))

# train_df$bin <- as.numeric(as.character(train_df$bin))
train_df <- train_df %>% left_join(df_phi, by = "bin")
train_df$id <- as.factor(train_df$id)
```

- Here, what if I replace "bin" with "t"? 

```{r, class.source = "fold-show"}
# usethis::edit_r_environ()
t1 <- Sys.time()
debias_glmm <- bam(Y ~ s(t, bs="cr", k=10)+
                     s(id, by=phi1, bs="re")+
                     s(id, by=phi2, bs="re")+
                     s(id, by=phi3, bs="re")+
                     s(id, by=phi4, bs="re"), 
                   family = binomial, data=train_df %>% filter(bin==sind), 
                   method = "fREML",
                   discrete = TRUE)
t2 <- Sys.time()
t_debias <- t2-t1
```

- And now I try to extract the variance of scores (debiased eigenvalues). 
- Use the conclusion that connects smoothing parameters to variance

$$\hat{p}_k=1/\hat{\lambda}_k^2$$

```{r}
fpca_mod$evalues
new_lambda <- 1/debias_glmm$sp[2:5]
new_lambda/lambda
fpca_mod$evalues[1:4]/new_lambda
```

- Looks like the re-evaluated variance is still inflated from the true eigenvalues, but indeed doubled the result of FPCA. 

#### Projection

Then I would like to project eigenfunctions using B-spline basis functions: 

- Would you interpolate mean and eigenfunctions separately (in my case, five interpolations)? 
- I did not find the reeval_efunctions function

```{r, fig.height=5, fig.width=5, class.source = "fold-show"}
# mean
interp_mean <- interpSpline(mid, fpca_mod$mu)
full_mean <- predict(interp_mean, x=1:J)
plot(mid, fpca_mod$mu, ylab = "mean", pch = 20)
lines(full_mean$x, full_mean$y, col = "blue")

# PCs
interp_phi1 <- interpSpline(mid, fpca_mod$efunctions[, 1])
full_phi1 <- predict(interp_phi1, x=1:J)
plot(mid, fpca_mod$efunctions[, 1], ylab = "pc1", pch=20)
lines(full_phi1$x, full_phi1$y, col = "blue")

interp_phi2 <- interpSpline(mid, fpca_mod$efunctions[, 2])
full_phi2 <- predict(interp_phi2, x=1:J)
plot(mid, fpca_mod$efunctions[, 2], ylab = "pc2", pch=20)
lines(full_phi2$x, full_phi2$y, col = "blue")

interp_phi3 <- interpSpline(mid, fpca_mod$efunctions[, 3])
full_phi3 <- predict(interp_phi3, x=1:J)
plot(mid, fpca_mod$efunctions[, 3], ylab = "pc3", pch=20)
lines(full_phi3$x, full_phi3$y, col = "blue")

interp_phi4 <- interpSpline(mid, fpca_mod$efunctions[, 4])
full_phi4 <- predict(interp_phi4, x=1:J)
plot(mid, fpca_mod$efunctions[, 4], ylab = "pc4", pch=20)
lines(full_phi4$x, full_phi4$y, col = "blue")
```

Perhaps I should try with the simulation data. 


# NHANES data

## Data overview

- 8763 subjects, 1440 measures each
- no missingness

```{r}
N <- length(unique(df$SEQN)) # sample size 8763
J <- max(df$sind) # 1440 measures per subject
```


```{r}
rand_id <- sample(unique(df$SEQN), size = 4) # "toy" sample

df %>% 
  filter(SEQN %in% rand_id) %>%
  ggplot()+
  geom_point(aes(x=sind, y=Z), size = 0.5)+
  facet_wrap(~SEQN)+
  labs(x="Time", y = "Activity", title = "A brief overview of the outcome")
```



## Out-of-sample prediction

follow up on the last report, I'll add some details here.

Let's set: 

- $s$: bin index
- $t_{m_s}$: midpoint time of bin s
- $\mathscr{T}_s$: all observation points in bin s
- $Y_i^s$ all observations in bin s from subject i. $Y_i^S := \{Y_i(t_j), t_j \in \mathscr{T}_s\}$

Let's assume we have a new subject $u$ with maximum observation time $T_u$. Then the log-likelihood of this new subject would be:

$$
l_u=\sum_{t_{m_s}<T_u}log(h(Y_u^s))+\hat{\eta}_u(t_{m_s})T(Y_u^s)-log(A[\hat{\eta}_u(t_{m_s})])
$$


where $\hat{\eta}_u(t_{m_s}) = \hat{\mu}_0(t_{m_s})+\sum_{k=1}^K \xi_{uk}\hat{\phi}(t_{m_s})$. 

From FPCA model (or the debias step to be added), we obtain $\hat{\mu}_0$, $\hat{\phi}_k$, as well as the variance estimates of $\xi_k$: $\hat{\lambda}_k$, and variance of residual process $\hat{\sigma^2}$.

With all these estimates, we wanna use Laplace approximation to find the $\xi_{uk}$ that maximizes $l_u$. 


I am using a package called **LaplacesDemon**, following this example https://cran.r-project.org/web/packages/LaplacesDemon/vignettes/LaplacesDemonTutorial.pdf

```{r, class.source = "fold-show"}
library(LaplacesDemon)
```


Now I am going to use one subject as an example to go over the approximation procedure:

First we write out the model: 

- Prior distribution: $\xi_{uk} \sim N(0, \hat{\lambda}_k)$
- Posterior distribution: 


\begin{aligned}
l(\mathbf{Y_u}|\mathbf{\xi}_u) &= \sum_{t_{m_s}<T_u}l(Y_u^s|\mathbf{\xi}_u) \\

Y_u^s|\mathbf{\xi}_u & \sim Binomial(n_s, p_s) \\

g^{-1}(p_s) = \hat{\eta}(t_{m_s}) &= \hat{\mu}_0(t_{m_s})+\sum_{k=1}^K \xi_{uk}\hat{\phi}(t_{m_s})
\end{aligned}



And $n_s$ is the number of observations in bin s. 

Bayes theroem:

$$
l(\mathbf{\xi}_u|\mathbf{Y}_u) \propto l(\mathbf{Y}_u|\mathbf{\xi}_u)+l(\mathbf{\xi}_u)
$$


```{r, class.source = "fold-show"}
## model
Model <- function(parm, Data){
  xi <- parm[Data$pos.xi]
  
  # log-prior
  xi.prior <- dmvnorm(xi, mean = rep(0, Data$J), sigma=Data$tao, log = TRUE)
  
  # log-posterior likelihood
  eta <- Data$f0+Data$X %*% xi
  p <- exp(eta)/(1+exp(eta))
  LL <- sum(dbinom(x=Data$y, size = Data$n, prob=p, log = TRUE)) # log likelihood of Y|xi
  LP <- LL+sum(xi.prior) # unnormalized joint log likelihood of (Y, xi)
  
  # output
  Modelout <- list(LP=LP, Dev=-2*LL, Monitor=LP,
                   yhat=Data$y, parm=parm)
  return(Modelout)
}
```


- Then we feed in data for one observation

```{r, class.source = "fold-show"}
rand_id <- test_id[15]
df_new <- df %>% filter(id == rand_id & sind <= 540) # observation until 9am

# put data into correct format
ns <- as.vector(table(df_new$bin)) # number of observations
hs <- df_new %>% group_by(bin) %>% summarize_at("Y", sum) %>% select(Y) %>% unlist()# number of success
nf <- ns-hs # number of failure
max_bin <- length(unique(df_new$bin)) # assume new skipped bins  
df_new2 <- data.frame(bin = unique(df_new$bin), ns, hs, nf)  
  
# extract estimates from FPCA model to be used in prior distribution
tao <- diag(fpca_mod$evalues[1:K]) # variance of xi

# extract estimates from FPCA model to be used in posterior distribution
f0 <- fpca_mod$mu[1:max_bin]
N <- nrow(df_new2) # "sample size" which is in fact number of observed bins in this case for a new subject
n <- df_new2$ns # number of experiements at each bin
y <- df_new2$hs # outcome, number of 1
X <- fpca_mod$efunctions[1:max_bin, 1:K] # eigen/PC functions
J <- K # number of parameters/scores
mon.names <- "LP"

# parameter names
name_lst <- as.list(rep(0, J))
names(name_lst) <- paste("xi", 1:J, sep = "")
parm.names <- as.parm.names(name_lst) # names of parameters to estimate
pos.xi <- grep("xi", parm.names)

# data
MyData <- list(J=J, X=X, mon.names=mon.names,
                 parm.names=parm.names, pos.xi=pos.xi, y=y, n=n, tao=tao, f0=f0)
```


```{r, class.source = "fold-show"}
# fit laplace approximation
# initial values generated by GIV function in the same package
Fit <- LaplaceApproximation(Model, Data=MyData)
```

- Summarizing output

```{r, class.source = "fold-show", fig.height=8, fig.width=8}
# summarizing output
print(Fit)
plot(Fit, MyData)
```

```{r}
# prediction
eta_pred_out <- fpca_mod$mu+fpca_mod$efunctions[, 1:K]%*%Fit$Summary1[, "Mode"]

data.frame(bin = mid, eta_pred = eta_pred_out) %>% 
  right_join(df %>% filter(id==rand_id) %>%  select(Y, sind, bin), by = "bin") %>%
  ggplot()+
  geom_point(aes(x=sind, y = Y))+
  geom_line(aes(x=sind, y = exp(eta_pred)/(1+exp(eta_pred))))+
  labs(title = rand_id)
  
```



# Full data application output

## fGFPCA

- Still need to project eigenfunctions to the full grid

```{r}
# results generated from DataApplNHANES.R
load(here("Data/ApplOutput_fGFPCA.RData"))
```




```{r message=FALSE, warning=FALSE}
df_test_full <- df %>% 
  filter(id %in% test_id) %>%
  filter(!id %in% skip_id) %>%
  left_join(df_test %>% select(id, bin, pred_t540, pred_t780, pred_t1020), by = c("id", "bin"))

rand_id2 <- sample(unique(df_test$id), 4)
# without interpolation, assume constant latent function value in each bin
df_test_full%>%
  filter(id %in% rand_id2) %>%
  mutate_at(vars(pred_t540, pred_t780, pred_t1020), function(x)exp(x)/(1+exp(x))) %>%
  ggplot()+
    geom_line(aes(x=bin, y = pred_t540, col = "9am"))+
    geom_line(aes(x=bin, y = pred_t780, col = "1pm"))+
    geom_line(aes(x=bin, y = pred_t1020, col = "5pm"))+
    geom_point(aes(x=bin, y = Y, col = "Outcome"), size = 0.2)+
    facet_wrap(~id)+
    labs(x = "Time", y = "Estimated latent function (probablity scale)",
         title = "Constant latent function within bin")
```

### Numeric problems 

- Three subjects had failed approximation, all happened with the shortest observed track
- Does it have to do with still the length of observed track? Or the arbitrary choices in the binning procedure (bin width). 
- Per last meeting, adding some details on laplace approximation


```{r, fig.height=3, fig.width=9}
df %>% filter(id %in% skip_id) %>% 
  ggplot()+
  geom_point(aes(x=sind, y=Y), size = 0.2)+
  facet_wrap(~id)+
  geom_vline(xintercept = c(540))
```


<!-- Calculate AUC -->


```{r}
# break by prediction window
lst_auc <- df_test_full %>% 
  mutate(window = cut(sind, breaks = c(0, 540, 780, 1020, 1260, 1440), 
                      labels = c("0-9am", "9am-1pm", "1pm-5pm", "5pm-9pm","9pm-12pm"), 
                      include.lowest = T))
lst_auc <- split(lst_auc, f=lst_auc$window)
```


```{r}
# no interpolation
# up to 9am
auc_t540 <- lst_auc[2:4] %>% 
  lapply(function(x)performance(prediction(x$pred_t540, x$Y), measure = "auc"))
auc_t540 <- lapply(auc_t540, function(x){x@y.values[[1]]}) %>% unlist()

# up to 1pm
auc_t780 <- lst_auc[3:4] %>% 
  lapply(function(x)performance(prediction(x$pred_t780, x$Y), measure = "auc"))
auc_t780 <- lapply(auc_t780, function(x){x@y.values[[1]]}) %>% unlist()

# up to 5pm
auc_t1020 <- lst_auc[4] %>% 
  lapply(function(x)performance(prediction(x$pred_t1020, x$Y), measure = "auc"))
auc_t1020 <- lapply(auc_t1020, function(x){x@y.values[[1]]}) %>% unlist()
```




## GLMMadaptvie

- when fitting model with **random intercept + slope** on the same full training set (even after scaling covariates): Error: vector memory exhausted (limit reached?).
- when fitting model with **only random intercept** on the same full training set: Error regarding a large coefficient value. One fix is to re-scale covariates. So I re-scaled minute index by dividing them by J, so the range is within (0, 1], and tried again. This fitting procedure took 20.72 minutes to finish



```{r}
load(here("Data/ApplOutput_GLMMadaptive.RData"))
```

- `r round(t_est_adglmm, 2)` minutes on model fitting and `r round(t_pred_adglmm, 2)` minutes on out-of-sample prediction. 

- Below is the model fit on the training set

```{r}
summary(adglmm_mod)
```



```{r}
df_test_full2 <- df_test_full %>%
  filter(id %in% rand_id2)%>%
  select(id, sind, Y)

df_test_full2$pred_t540 <- df_test_full2$pred_t780 <- df_test_full2$pred_t1020 <- NA 
for(i in rand_id2){
  df_test_full2[df_test_full2$id==i & df_test_full2$sind>540, "pred_t540"]<- adglmm_pred_t540$newdata2 %>% filter(id ==i) %>% select(pred)
  
  df_test_full2[df_test_full2$id==i & df_test_full2$sind>780, "pred_t780"]<- adglmm_pred_t780$newdata2 %>% filter(id ==i) %>% select(pred)
  
  df_test_full2[df_test_full2$id==i & df_test_full2$sind>1020, "pred_t1020"]<- adglmm_pred_t1020$newdata2 %>% filter(id ==i) %>% select(pred)
}

# colSums(is.na(df_test_full2))
```



- Below is an example of predicted probablity on four random subjects

```{r, warning=FALSE}
df_test_full2 %>% 
  mutate_at(vars(pred_t540, pred_t780, pred_t1020), 
            function(x)exp(x)/(1+exp(x))) %>%
  ggplot()+
    geom_line(aes(x=sind, y = pred_t540, col = "9am"))+
    geom_line(aes(x=sind, y = pred_t780, col = "1pm"))+
    geom_line(aes(x=sind, y = pred_t1020, col = "5pm"))+
    geom_point(aes(x=sind, y = Y, col = "Outcome"), size = 0.2)+
    facet_wrap(~id)+
    labs(x = "Time", y = "Estimated latent function (probablity scale)")
```

<!-- Calculate AUC  -->



```{r}
# up to 540
J <- 1440
auc_t540_adglmm <- adglmm_pred_t540$newdata2 %>%
  filter(!id %in% skip_id) %>%
  mutate(sind=sind*J) %>%
  mutate(window = cut(sind, breaks = c(540, 780, 1020, 1260, 1440), 
                      labels = c("9am-1pm", "1pm-5pm", "5pm-9pm","9pm-12pm"), 
                      include.lowest = T))
auc_t540_adglmm <- split(auc_t540_adglmm, f=auc_t540_adglmm$window)
auc_t540_adglmm <- auc_t540_adglmm[1:3] %>% 
  lapply(function(x)performance(prediction(x$pred, x$Y), measure = "auc"))
auc_t540_adglmm <- lapply(auc_t540_adglmm, function(x){x@y.values[[1]]}) %>% unlist()

# up to 780
auc_t780_adglmm <- adglmm_pred_t780$newdata2 %>%
  filter(!id %in% skip_id) %>%
  mutate(sind=sind*J) %>%
  mutate(window = cut(sind, breaks = c(780, 1020, 1260, 1440), 
                      labels = c("1pm-5pm", "5pm-9pm","9pm-12pm"), 
                      include.lowest = T))
auc_t780_adglmm <- split(auc_t780_adglmm, f=auc_t780_adglmm$window)
auc_t780_adglmm <- auc_t780_adglmm[1:2] %>% 
  lapply(function(x)performance(prediction(x$pred, x$Y), measure = "auc"))
auc_t780_adglmm <- lapply(auc_t780_adglmm, function(x){x@y.values[[1]]}) %>% unlist()

# up to 1020
auc_t1020_adglmm <- adglmm_pred_t1020$newdata2 %>%
  filter(!id %in% skip_id) %>%
  mutate(sind=sind*J) %>%
  mutate(window = cut(sind, breaks = c(1020, 1260, 1440), 
                      labels = c("5pm-9pm","9pm-12pm"), 
                      include.lowest = T))
auc_t1020_adglmm <- split(auc_t1020_adglmm, f=auc_t1020_adglmm$window)
auc_t1020_adglmm <- auc_t1020_adglmm[1] %>% 
  lapply(function(x)performance(prediction(x$pred, x$Y), measure = "auc"))
auc_t1020_adglmm <- lapply(auc_t1020_adglmm, function(x){x@y.values[[1]]}) %>% unlist()


```


## Compare fGFPCA and GLMMadaptive

- To use the same sample for comparison, I'd exclude the subjects with failed Laplace approximation from the test set for both methods

```{r}
options(knitr.kable.NA = '')
tb_auc <- data.frame(auc_t540, 
           c(NA, auc_t780), 
           c(NA, NA, auc_t1020), 
        
           auc_t540_adglmm,
           c(NA, auc_t780_adglmm), 
           c(NA, NA, auc_t1020_adglmm))

colnames(tb_auc) <- rep(c("9am", "1pm", "5pm"), 2)
```


```{r}
# time
t_fit <- c(t_local_glmm+t_fpca, t_est_adglmm)
units(t_fit) <- "mins"

t_test <- c(t_pred, t_pred_adglmm)
# units(t_pred)

t_total <- t_fit+t_test


idx1 <- idx2 <- idx3 <- c(1, 3, 3)
names(idx1) <- c("Total time", as.character(round(t_total, 2)))
names(idx2) <- c("Time on prediction", as.character(round(t_test, 2)))
names(idx3) <- c("Time on model fitting", as.character(round(t_fit, 2)))

t_fit <- as.character(round(t_fit, 2))
t_test <- as.character(round(t_test, 2))
t_total <- as.character(round(t_total, 2))

```



```{r}
tb_auc %>%
  kable(digit = 4, table.attr = "style = \"color: black;\"") %>%
  kable_styling(full_width = F) %>% 
  add_header_above(header=idx1) %>%
  add_header_above(header=idx2) %>%
  add_header_above(header=idx3) %>%
  add_header_above(c(" "=1, "fGFPCA"=3, "GLMMadaptive"=3))
```

- fGFPCA does not always have higher AUC, but definitely most of the time. 
- In fact there are two scenarios where GLMMadaptive outperforms fGFPCA slightly: 1) given 9am to predict 1-5pm; and 2) given 1pm and predict 5-9pm. Both of them have a 4-hour interval apart from the maximum observation time and and prediction window. Could it have anything to do the cyclic trend in the data? Is 4h the length of a cycle? I tried to look at it but really couldn't see anything...there are too many points lumped together! 


```{r}
df %>% filter(id %in% rand_id2) %>%
  ggplot()+
  geom_point(aes(x=sind, y=Y), size = 0.2)+
  geom_vline(xintercept = c(540, 780, 1020, 1260))+
  scale_x_continuous(breaks = c(540, 780, 1020, 1260),
                     labels = c("9am", "1pm", "5pm", "9pm"))+
  facet_wrap(~id)
```

## Discussion

- What would be the reference method to compare our performance to? Original GLMMadaptvie perhaps is feasible on the entire dataset. But what should we use if we wanna do sub-sample comparison? Should we even do that for this data application (or simulation alone)? 
- There are still three participants with numeric problem! Shall we extend the observation track even more? I suspect that may cause still the same issue just on different subjects. 
- Is interpolation really necessary? It does not improve performance very much but consumes time. Also, should I try more sophisticated methods for grid extension? 
- Should I calculate subject-wise AUC and average them? But some subjects are all zero within the prediction window, making AUC for this single subjects impossible to calculate...

